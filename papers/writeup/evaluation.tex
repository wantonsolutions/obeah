\section{Evaluation and Discussion}
\label{sec:evaluation}

Obeah is a young tool, and as such it has not been evaluated on large byzantine
fault tolerant distributed systems. This section details some of the preliminary
results of Obeah on small single processor systems, and on a singular example
of a toy distributed system. Further we account some of our experiences
working with Obeah as anecdotal evidence of its potential worth.

\noindent\textbf{Small sequential systems} In developing Obeah a set of test
programs were written to test both its instrumentation, and ability to detect
and access low probability control flow paths. The largest of these systems was
550LOC and contained 50 branching conditions of containing \emph{if-else}, and
\emph{switch} statements. Obeah correctly generated the set of constraints for
each conditional and instrumented logging functionality in the system in less
than one second. Obeah's instrumentation tool uses package level information to
generate unique logging statements, and could easily instrument larger systems.

Each of the small systems contained a number of conditions which required that
variables have precise values, for example \emph{$x == 5$}. During the
execution of these systems random values were used to set variables. Random
values were used to simulate traditional black box fuzz testing. Of the precise
conditionals many were nested. A few of these precise nested conditionals had
crash statements hard coded in. Each of the systems was executed for 120
seconds using random input to attempt and in the nested crash statements, in
all cases random testing was unable to reach them. The profiles of the nested
systems were then used to generate low probability paths.

We applied Obeah to each of these systems to measure the time necessary to
solve the constraints and generate variable values which could reach the crash
statements. Z3 is a fast constraint solver, and the majority of the constraints
in the small programs consisted of less than 50 clauses. In all cases where
satisfying assignments existed Obeah was able to generate them in less than 5
seconds.

To test Obeah's performance in cases where satisfying assignments did not exist,
another test program was built containing 30 conditionals and spanning 70 LOC.
In this program 5 crash statements existed, none of which were reachable. Obeah
spent a total of 60 seconds solving all low probability constraints before
concluding they were unsatisfiable and moving on. 60 seconds is an unacceptable
amount of time for a distributed system to stall out, as many of the other
nodes in the system would issue timeouts for the blocked node. We submit that
in the future much of the unsatisfiable control flow paths could be computed
apriori without causing the program to block.

\noindent\textbf{Small distributed system} To test Obeah on a distributed
system we ran it on a fault tolerant implementation of Ricart-Agrawala mutual
exclusion algorithm. This system was not built to withstand byzantine faults,
but the failures generated by running with a single Obeah node indicate that it
can generate faults. Due to timing constraints no efficiency data was collected
from the systems execution.

Many of the faults generated by obeah cause the instrumented node itself to
fail. In the implementation a message which caused a node to kill itself was a
potential received message. As this was low probability behaviour on most executions
Obeah set the incoming message type to \emph{KILL} and ended the nodes
execution.

In one noteworthy execution, the Obeah node issued a message that it had
detected the death of another node in the system. In this instance the
un-comprimised node which received the message removed the node from is cluster
membership list. A compromised membership list caused the faulted node to no
longer request critical section permission from the node it had removed. On a
long enough execution this would have resulted in a violation of the systems
mutual exclusion.

\noindent\textbf{Experiences} Obeah is a work in progress and there are a
number of improvements which would ease it's usability and the safety of its
users. First, using the log of only the instrumented node to reason about the
failures of other nodes in the system is difficult. In the Ricart-Agrawala
example we spent over an hour to determine the cause of the fault using tools
for reasoning about the systems execution.

Of paramount importance is the dangers users currently face while running
Obeah. The tool aims to execute low probability code paths. This may be useful
for detecting bugs, but it can also be harmfull to the environment it is
executing in. During one run of Ricart-Agrawala, Obeah executed code for
writing out node information to a file. The original program took an integer to
specify the size of the file to be written. Obeah set the size of the file to
over 3GB and continuously wrote it for over a minute. The result was memory
panic errors from the kernel. Users wishing to use the current implementation of
Obeah should sand box it within a virtual environment. In the future system
calls may have to be disabled.
